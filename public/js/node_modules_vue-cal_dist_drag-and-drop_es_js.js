"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_vue-cal_dist_drag-and-drop_es_js"],{

/***/ "./node_modules/vue-cal/dist/drag-and-drop.es.js":
/*!*******************************************************!*\
  !*** ./node_modules/vue-cal/dist/drag-and-drop.es.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragAndDrop: () => (/* binding */ DragAndDrop)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n/**\n  * vue-cal v4.10.2\n  * (c) 2025 Antoni Andre <antoniandre.web@gmail.com>\n  * @license MIT\n  */\nconst holdOverTimeout = 800;\nlet changeViewTimeout = null;\nlet pressPrevOrNextInterval = null;\nlet viewBeforeDrag = { id: null, date: null };\nlet viewChanged = false;\nlet cancelViewChange = true;\nlet dragOverCell = { el: null, cell: null, timeout: null };\nconst dragging = {\n  _eid: null,\n  fromVueCal: null,\n  toVueCal: null\n};\nconst DragAndDrop = class {\n  constructor(vuecal) {\n    __publicField(this, \"_vuecal\");\n    this._vuecal = vuecal;\n  }\n  /**\n   * When click and drag an event the cursor can be anywhere in the event,\n   * when dropping the event, we need to subtract the cursor position in the event.\n   *\n   * @param {Object} e The associated DOM event.\n   */\n  _getEventStart(e) {\n    const { timeStep, timeCellHeight, timeFrom, utils } = this._vuecal;\n    let { y } = utils.cell.getPosition(e);\n    y -= e.dataTransfer.getData(\"cursor-grab-at\") * 1;\n    return Math.round(y * timeStep / parseInt(timeCellHeight) + timeFrom);\n  }\n  /**\n   * On drop, update the event start and end date directly into the event.\n   *\n   * @param {Object} e The associated DOM event.\n   * @param {Object} event The event being dragged.\n   * @param {Object} transferData The transfer data from the HTML5 dragging event.\n   * @param {Date} cellDate The hovered cell starting date.\n   */\n  _updateEventStartEnd(e, event, transferData, cellDate) {\n    const eventDuration = transferData.duration * 1 || event.endTimeMinutes - event.startTimeMinutes;\n    let startTimeMinutes = Math.max(this._getEventStart(e), 0);\n    if (this._vuecal.snapToTime) {\n      const plusHalfSnapTime = startTimeMinutes + this._vuecal.snapToTime / 2;\n      startTimeMinutes = plusHalfSnapTime - plusHalfSnapTime % this._vuecal.snapToTime;\n    }\n    event.startTimeMinutes = startTimeMinutes;\n    event.start = new Date(new Date(cellDate).setMinutes(startTimeMinutes));\n    event.endTimeMinutes = Math.min(startTimeMinutes + eventDuration, 24 * 60);\n    event.end = new Date(new Date(cellDate).setMinutes(event.endTimeMinutes));\n  }\n  /**\n   * On event drag start, only possible if editableEvent is true.\n   * /!\\ This is using the native HTML5 drag & drop, not supported on touch devices.\n   *\n   * @param {Object} e The associated DOM event.\n   * @param {Object} event The event being dragged.\n   */\n  eventDragStart(e, event) {\n    if (e.target.nodeType === 3) return e.preventDefault();\n    e.dataTransfer.dropEffect = \"move\";\n    e.dataTransfer.setData(\"event\", JSON.stringify(event));\n    e.dataTransfer.setData(\"cursor-grab-at\", e.offsetY);\n    const { clickHoldAnEvent } = this._vuecal.domEvents;\n    setTimeout(() => {\n      clickHoldAnEvent._eid = null;\n      clearTimeout(clickHoldAnEvent.timeoutId);\n      event.deleting = false;\n    }, 0);\n    this._vuecal.domEvents.dragAnEvent._eid = event._eid;\n    dragging._eid = event._eid;\n    dragging.fromVueCal = this._vuecal._.uid;\n    event.dragging = true;\n    setTimeout(() => event.draggingStatic = true, 0);\n    viewChanged = false;\n    viewBeforeDrag = { id: this._vuecal.view.id, date: this._vuecal.view.startDate };\n    cancelViewChange = true;\n  }\n  /**\n   * On event drag end, when releasing the event.\n   *\n   * @param {Object} event The event being dragged.\n   */\n  eventDragEnd(event) {\n    this._vuecal.domEvents.dragAnEvent._eid = null;\n    dragging._eid = null;\n    event.dragging = false;\n    event.draggingStatic = false;\n    const { fromVueCal, toVueCal } = dragging;\n    if (toVueCal && fromVueCal !== toVueCal) this._vuecal.utils.event.deleteAnEvent(event);\n    dragging.fromVueCal = null;\n    dragging.toVueCal = null;\n    if (viewChanged && cancelViewChange && viewBeforeDrag.id) this._vuecal.switchView(viewBeforeDrag.id, viewBeforeDrag.date, true);\n  }\n  /**\n   * On cell/split enter with a dragging event.\n   * Highlight the cell, and if on `years`, `year`, `month` view,\n   * set a timer to go deeper on drag hold over this cell.\n   *\n   * @param {Object} e The associated DOM event.\n   * @param {Object} cell The cell component's $data.\n   * @param {Date} cellDate The hovered cell starting date.\n   */\n  cellDragEnter(e, cell, cellDate) {\n    const target = e.currentTarget;\n    if (e.currentTarget.contains(e.relatedTarget)) return;\n    if (target === dragOverCell.el || !target.className.includes(\"vuecal__cell-content\")) return false;\n    if (dragOverCell.el) dragOverCell.cell.highlighted = false;\n    dragOverCell = { el: target, cell, timeout: clearTimeout(dragOverCell.timeout) };\n    cell.highlighted = true;\n    if ([\"years\", \"year\", \"month\"].includes(this._vuecal.view.id)) {\n      dragOverCell.timeout = setTimeout(() => this._vuecal.switchToNarrowerView(cellDate), 2e3);\n    }\n  }\n  /**\n   * On cell/split drag over, highlight the cell being hovered,\n   * Useful when starting to drag event on the same cell/split it's in.\n   * Warning: This is fired repeatedly as long as you stay over this cell/split.\n   *\n   * @param {Object} e The associated DOM event.\n   * @param {Object} cell The cell component's $data.\n   * @param {Date} cellDate The hovered cell starting date.\n   * @param {Number|String} split The optional split being hovered if any.\n   */\n  cellDragOver(e, cell, cellDate, split) {\n    e.preventDefault();\n    cell.highlighted = true;\n    if (split || split === 0) cell.highlightedSplit = split;\n  }\n  /**\n   * When event drag leaves a cell/split.\n   * Remove the cell/split highlighted state.\n   * Warning: cell dragleave event happens AFTER another cell dragenter!\n   *\n   * @param {Object} e The associated DOM event.\n   * @param {Object} cell The cell component's $data.\n   */\n  cellDragLeave(e, cell) {\n    e.preventDefault();\n    if (e.currentTarget.contains(e.relatedTarget)) return;\n    cell.highlightedSplit = false;\n    if (dragOverCell.cell === cell) {\n      clearTimeout(dragOverCell.timeout);\n      dragOverCell = { el: null, cell: null, timeout: null };\n      cell.highlighted = false;\n    }\n  }\n  /**\n   * On successful event drop into a cell/split.\n   * Change the event start and end time and remove the event dragging state\n   * and cell/split highlighted state.\n   *\n   * @param {Object} e The associated DOM event.\n   * @param {Object} cell The cell component's $data.\n   * @param {Date} cellDate The hovered cell starting date.\n   * @param {Number|String} split The optional split being dropped into, if any.\n   */\n  cellDragDrop(e, cell, cellDate, split) {\n    e.preventDefault();\n    clearTimeout(dragOverCell.timeout);\n    dragOverCell = { el: null, cell: null, timeout: null };\n    const transferData = JSON.parse(e.dataTransfer.getData(\"event\") || \"{}\");\n    let event, addToView;\n    if (dragging.fromVueCal !== this._vuecal._.uid) {\n      const { _eid, start, end, duration, ...cleanTransferData } = transferData;\n      event = this._vuecal.utils.event.createAnEvent(cellDate, duration, { ...cleanTransferData, split });\n    } else {\n      event = this._vuecal.view.events.find((evt) => evt._eid === dragging._eid);\n      if (!event) {\n        event = this._vuecal.mutableEvents.find((evt) => evt._eid === dragging._eid);\n        addToView = !!event;\n      }\n      if (!event) {\n        const duration = transferData.endTimeMinutes - transferData.startTimeMinutes;\n        const { start, end, ...cleanTransferData } = transferData;\n        event = this._vuecal.utils.event.createAnEvent(cellDate, duration, { ...cleanTransferData, split });\n      }\n    }\n    const { start: oldDate, split: oldSplit } = event;\n    this._updateEventStartEnd(e, event, transferData, cellDate);\n    if (addToView) this._vuecal.addEventsToView([event]);\n    event.dragging = false;\n    if (split || split === 0) event.split = split;\n    cell.highlighted = false;\n    cell.highlightedSplit = null;\n    cancelViewChange = false;\n    dragging.toVueCal = this._vuecal._.uid;\n    const params = {\n      event: this._vuecal.cleanupEvent(event),\n      oldDate,\n      newDate: event.start,\n      ...(split || split === 0) && { oldSplit, newSplit: split },\n      originalEvent: this._vuecal.cleanupEvent(transferData),\n      external: !dragging.fromVueCal\n      // If external event, not coming from any Vue Cal.\n    };\n    this._vuecal.$emit(\"event-drop\", params);\n    this._vuecal.$emit(\"event-change\", { event: params.event, originalEvent: params.originalEvent });\n    setTimeout(() => {\n      if (dragging._eid) this.eventDragEnd(event);\n    }, 300);\n  }\n  /**\n   * On drag enter on a view button or on today, prev & next buttons.\n   * Sets a highlighted state on the hovered button, and go to requested view.\n   *\n   * @param {Object} e The associated DOM event.\n   * @param {String} id The id of the header element being hovered. One of:\n   *                    previous, next, today, years, year, month, week, day.\n   * @param {Object} headerData The header component's $data.\n   */\n  viewSelectorDragEnter(e, id, headerData) {\n    if (e.currentTarget.contains(e.relatedTarget)) return;\n    headerData.highlightedControl = id;\n    clearTimeout(changeViewTimeout);\n    changeViewTimeout = setTimeout(() => {\n      if ([\"previous\", \"next\"].includes(id)) {\n        this._vuecal[id]();\n        clearInterval(pressPrevOrNextInterval);\n        pressPrevOrNextInterval = setInterval(this._vuecal[id], holdOverTimeout);\n      } else if (id === \"today\") {\n        clearInterval(pressPrevOrNextInterval);\n        let viewId;\n        if (this._vuecal.view.id.includes(\"year\")) {\n          viewId = this._vuecal.enabledViews.filter((view) => !view.includes(\"year\"))[0];\n        }\n        this._vuecal.switchView(viewId || this._vuecal.view.id, new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0)), true);\n      } else this._vuecal.switchView(id, null, true);\n      viewChanged = true;\n    }, holdOverTimeout);\n  }\n  /**\n   * On drag leave on a view button or on today, prev & next buttons.\n   * Removes the highlighted state on the hovered button, and cancel the timer to\n   * go to the requested view.\n   *\n   * @param {Object} e The associated DOM event.\n   * @param {String} id The id of the header element being hovered. One of:\n   *                    previous, next, today, years, year, month, week, day.\n   * @param {Object} headerData The header component's $data.\n   */\n  viewSelectorDragLeave(e, id, headerData) {\n    if (e.currentTarget.contains(e.relatedTarget)) return;\n    if (headerData.highlightedControl === id) {\n      headerData.highlightedControl = null;\n      if (changeViewTimeout) changeViewTimeout = clearTimeout(changeViewTimeout);\n      if (pressPrevOrNextInterval) pressPrevOrNextInterval = clearInterval(pressPrevOrNextInterval);\n    }\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLWNhbC9kaXN0L2RyYWctYW5kLWRyb3AuZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxZQUFZLDRDQUE0QztBQUN4RCxVQUFVLElBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLGNBQWMsbURBQW1EO0FBQ2pFLDJFQUEyRSw2QkFBNkI7QUFDeEcsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1DQUFtQztBQUNuRCw2RUFBNkUsNkJBQTZCO0FBQzFHO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkJBQTJCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMERBQTBEO0FBQ25HO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtY2FsL2Rpc3QvZHJhZy1hbmQtZHJvcC5lcy5qcz9kOTNlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4vKipcbiAgKiB2dWUtY2FsIHY0LjEwLjJcbiAgKiAoYykgMjAyNSBBbnRvbmkgQW5kcmUgPGFudG9uaWFuZHJlLndlYkBnbWFpbC5jb20+XG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG5jb25zdCBob2xkT3ZlclRpbWVvdXQgPSA4MDA7XG5sZXQgY2hhbmdlVmlld1RpbWVvdXQgPSBudWxsO1xubGV0IHByZXNzUHJldk9yTmV4dEludGVydmFsID0gbnVsbDtcbmxldCB2aWV3QmVmb3JlRHJhZyA9IHsgaWQ6IG51bGwsIGRhdGU6IG51bGwgfTtcbmxldCB2aWV3Q2hhbmdlZCA9IGZhbHNlO1xubGV0IGNhbmNlbFZpZXdDaGFuZ2UgPSB0cnVlO1xubGV0IGRyYWdPdmVyQ2VsbCA9IHsgZWw6IG51bGwsIGNlbGw6IG51bGwsIHRpbWVvdXQ6IG51bGwgfTtcbmNvbnN0IGRyYWdnaW5nID0ge1xuICBfZWlkOiBudWxsLFxuICBmcm9tVnVlQ2FsOiBudWxsLFxuICB0b1Z1ZUNhbDogbnVsbFxufTtcbmNvbnN0IERyYWdBbmREcm9wID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2dWVjYWwpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX3Z1ZWNhbFwiKTtcbiAgICB0aGlzLl92dWVjYWwgPSB2dWVjYWw7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gY2xpY2sgYW5kIGRyYWcgYW4gZXZlbnQgdGhlIGN1cnNvciBjYW4gYmUgYW55d2hlcmUgaW4gdGhlIGV2ZW50LFxuICAgKiB3aGVuIGRyb3BwaW5nIHRoZSBldmVudCwgd2UgbmVlZCB0byBzdWJ0cmFjdCB0aGUgY3Vyc29yIHBvc2l0aW9uIGluIHRoZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGFzc29jaWF0ZWQgRE9NIGV2ZW50LlxuICAgKi9cbiAgX2dldEV2ZW50U3RhcnQoZSkge1xuICAgIGNvbnN0IHsgdGltZVN0ZXAsIHRpbWVDZWxsSGVpZ2h0LCB0aW1lRnJvbSwgdXRpbHMgfSA9IHRoaXMuX3Z1ZWNhbDtcbiAgICBsZXQgeyB5IH0gPSB1dGlscy5jZWxsLmdldFBvc2l0aW9uKGUpO1xuICAgIHkgLT0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcImN1cnNvci1ncmFiLWF0XCIpICogMTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh5ICogdGltZVN0ZXAgLyBwYXJzZUludCh0aW1lQ2VsbEhlaWdodCkgKyB0aW1lRnJvbSk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGRyb3AsIHVwZGF0ZSB0aGUgZXZlbnQgc3RhcnQgYW5kIGVuZCBkYXRlIGRpcmVjdGx5IGludG8gdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgZXZlbnQgYmVpbmcgZHJhZ2dlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZmVyRGF0YSBUaGUgdHJhbnNmZXIgZGF0YSBmcm9tIHRoZSBIVE1MNSBkcmFnZ2luZyBldmVudC5cbiAgICogQHBhcmFtIHtEYXRlfSBjZWxsRGF0ZSBUaGUgaG92ZXJlZCBjZWxsIHN0YXJ0aW5nIGRhdGUuXG4gICAqL1xuICBfdXBkYXRlRXZlbnRTdGFydEVuZChlLCBldmVudCwgdHJhbnNmZXJEYXRhLCBjZWxsRGF0ZSkge1xuICAgIGNvbnN0IGV2ZW50RHVyYXRpb24gPSB0cmFuc2ZlckRhdGEuZHVyYXRpb24gKiAxIHx8IGV2ZW50LmVuZFRpbWVNaW51dGVzIC0gZXZlbnQuc3RhcnRUaW1lTWludXRlcztcbiAgICBsZXQgc3RhcnRUaW1lTWludXRlcyA9IE1hdGgubWF4KHRoaXMuX2dldEV2ZW50U3RhcnQoZSksIDApO1xuICAgIGlmICh0aGlzLl92dWVjYWwuc25hcFRvVGltZSkge1xuICAgICAgY29uc3QgcGx1c0hhbGZTbmFwVGltZSA9IHN0YXJ0VGltZU1pbnV0ZXMgKyB0aGlzLl92dWVjYWwuc25hcFRvVGltZSAvIDI7XG4gICAgICBzdGFydFRpbWVNaW51dGVzID0gcGx1c0hhbGZTbmFwVGltZSAtIHBsdXNIYWxmU25hcFRpbWUgJSB0aGlzLl92dWVjYWwuc25hcFRvVGltZTtcbiAgICB9XG4gICAgZXZlbnQuc3RhcnRUaW1lTWludXRlcyA9IHN0YXJ0VGltZU1pbnV0ZXM7XG4gICAgZXZlbnQuc3RhcnQgPSBuZXcgRGF0ZShuZXcgRGF0ZShjZWxsRGF0ZSkuc2V0TWludXRlcyhzdGFydFRpbWVNaW51dGVzKSk7XG4gICAgZXZlbnQuZW5kVGltZU1pbnV0ZXMgPSBNYXRoLm1pbihzdGFydFRpbWVNaW51dGVzICsgZXZlbnREdXJhdGlvbiwgMjQgKiA2MCk7XG4gICAgZXZlbnQuZW5kID0gbmV3IERhdGUobmV3IERhdGUoY2VsbERhdGUpLnNldE1pbnV0ZXMoZXZlbnQuZW5kVGltZU1pbnV0ZXMpKTtcbiAgfVxuICAvKipcbiAgICogT24gZXZlbnQgZHJhZyBzdGFydCwgb25seSBwb3NzaWJsZSBpZiBlZGl0YWJsZUV2ZW50IGlzIHRydWUuXG4gICAqIC8hXFwgVGhpcyBpcyB1c2luZyB0aGUgbmF0aXZlIEhUTUw1IGRyYWcgJiBkcm9wLCBub3Qgc3VwcG9ydGVkIG9uIHRvdWNoIGRldmljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBhc3NvY2lhdGVkIERPTSBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCBiZWluZyBkcmFnZ2VkLlxuICAgKi9cbiAgZXZlbnREcmFnU3RhcnQoZSwgZXZlbnQpIHtcbiAgICBpZiAoZS50YXJnZXQubm9kZVR5cGUgPT09IDMpIHJldHVybiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiO1xuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJldmVudFwiLCBKU09OLnN0cmluZ2lmeShldmVudCkpO1xuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJjdXJzb3ItZ3JhYi1hdFwiLCBlLm9mZnNldFkpO1xuICAgIGNvbnN0IHsgY2xpY2tIb2xkQW5FdmVudCB9ID0gdGhpcy5fdnVlY2FsLmRvbUV2ZW50cztcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNsaWNrSG9sZEFuRXZlbnQuX2VpZCA9IG51bGw7XG4gICAgICBjbGVhclRpbWVvdXQoY2xpY2tIb2xkQW5FdmVudC50aW1lb3V0SWQpO1xuICAgICAgZXZlbnQuZGVsZXRpbmcgPSBmYWxzZTtcbiAgICB9LCAwKTtcbiAgICB0aGlzLl92dWVjYWwuZG9tRXZlbnRzLmRyYWdBbkV2ZW50Ll9laWQgPSBldmVudC5fZWlkO1xuICAgIGRyYWdnaW5nLl9laWQgPSBldmVudC5fZWlkO1xuICAgIGRyYWdnaW5nLmZyb21WdWVDYWwgPSB0aGlzLl92dWVjYWwuXy51aWQ7XG4gICAgZXZlbnQuZHJhZ2dpbmcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQuZHJhZ2dpbmdTdGF0aWMgPSB0cnVlLCAwKTtcbiAgICB2aWV3Q2hhbmdlZCA9IGZhbHNlO1xuICAgIHZpZXdCZWZvcmVEcmFnID0geyBpZDogdGhpcy5fdnVlY2FsLnZpZXcuaWQsIGRhdGU6IHRoaXMuX3Z1ZWNhbC52aWV3LnN0YXJ0RGF0ZSB9O1xuICAgIGNhbmNlbFZpZXdDaGFuZ2UgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBPbiBldmVudCBkcmFnIGVuZCwgd2hlbiByZWxlYXNpbmcgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIGV2ZW50IGJlaW5nIGRyYWdnZWQuXG4gICAqL1xuICBldmVudERyYWdFbmQoZXZlbnQpIHtcbiAgICB0aGlzLl92dWVjYWwuZG9tRXZlbnRzLmRyYWdBbkV2ZW50Ll9laWQgPSBudWxsO1xuICAgIGRyYWdnaW5nLl9laWQgPSBudWxsO1xuICAgIGV2ZW50LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgZXZlbnQuZHJhZ2dpbmdTdGF0aWMgPSBmYWxzZTtcbiAgICBjb25zdCB7IGZyb21WdWVDYWwsIHRvVnVlQ2FsIH0gPSBkcmFnZ2luZztcbiAgICBpZiAodG9WdWVDYWwgJiYgZnJvbVZ1ZUNhbCAhPT0gdG9WdWVDYWwpIHRoaXMuX3Z1ZWNhbC51dGlscy5ldmVudC5kZWxldGVBbkV2ZW50KGV2ZW50KTtcbiAgICBkcmFnZ2luZy5mcm9tVnVlQ2FsID0gbnVsbDtcbiAgICBkcmFnZ2luZy50b1Z1ZUNhbCA9IG51bGw7XG4gICAgaWYgKHZpZXdDaGFuZ2VkICYmIGNhbmNlbFZpZXdDaGFuZ2UgJiYgdmlld0JlZm9yZURyYWcuaWQpIHRoaXMuX3Z1ZWNhbC5zd2l0Y2hWaWV3KHZpZXdCZWZvcmVEcmFnLmlkLCB2aWV3QmVmb3JlRHJhZy5kYXRlLCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogT24gY2VsbC9zcGxpdCBlbnRlciB3aXRoIGEgZHJhZ2dpbmcgZXZlbnQuXG4gICAqIEhpZ2hsaWdodCB0aGUgY2VsbCwgYW5kIGlmIG9uIGB5ZWFyc2AsIGB5ZWFyYCwgYG1vbnRoYCB2aWV3LFxuICAgKiBzZXQgYSB0aW1lciB0byBnbyBkZWVwZXIgb24gZHJhZyBob2xkIG92ZXIgdGhpcyBjZWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsIFRoZSBjZWxsIGNvbXBvbmVudCdzICRkYXRhLlxuICAgKiBAcGFyYW0ge0RhdGV9IGNlbGxEYXRlIFRoZSBob3ZlcmVkIGNlbGwgc3RhcnRpbmcgZGF0ZS5cbiAgICovXG4gIGNlbGxEcmFnRW50ZXIoZSwgY2VsbCwgY2VsbERhdGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQ7XG4gICAgaWYgKGUuY3VycmVudFRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSByZXR1cm47XG4gICAgaWYgKHRhcmdldCA9PT0gZHJhZ092ZXJDZWxsLmVsIHx8ICF0YXJnZXQuY2xhc3NOYW1lLmluY2x1ZGVzKFwidnVlY2FsX19jZWxsLWNvbnRlbnRcIikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZHJhZ092ZXJDZWxsLmVsKSBkcmFnT3ZlckNlbGwuY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgIGRyYWdPdmVyQ2VsbCA9IHsgZWw6IHRhcmdldCwgY2VsbCwgdGltZW91dDogY2xlYXJUaW1lb3V0KGRyYWdPdmVyQ2VsbC50aW1lb3V0KSB9O1xuICAgIGNlbGwuaGlnaGxpZ2h0ZWQgPSB0cnVlO1xuICAgIGlmIChbXCJ5ZWFyc1wiLCBcInllYXJcIiwgXCJtb250aFwiXS5pbmNsdWRlcyh0aGlzLl92dWVjYWwudmlldy5pZCkpIHtcbiAgICAgIGRyYWdPdmVyQ2VsbC50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl92dWVjYWwuc3dpdGNoVG9OYXJyb3dlclZpZXcoY2VsbERhdGUpLCAyZTMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT24gY2VsbC9zcGxpdCBkcmFnIG92ZXIsIGhpZ2hsaWdodCB0aGUgY2VsbCBiZWluZyBob3ZlcmVkLFxuICAgKiBVc2VmdWwgd2hlbiBzdGFydGluZyB0byBkcmFnIGV2ZW50IG9uIHRoZSBzYW1lIGNlbGwvc3BsaXQgaXQncyBpbi5cbiAgICogV2FybmluZzogVGhpcyBpcyBmaXJlZCByZXBlYXRlZGx5IGFzIGxvbmcgYXMgeW91IHN0YXkgb3ZlciB0aGlzIGNlbGwvc3BsaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBhc3NvY2lhdGVkIERPTSBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNlbGwgVGhlIGNlbGwgY29tcG9uZW50J3MgJGRhdGEuXG4gICAqIEBwYXJhbSB7RGF0ZX0gY2VsbERhdGUgVGhlIGhvdmVyZWQgY2VsbCBzdGFydGluZyBkYXRlLlxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHNwbGl0IFRoZSBvcHRpb25hbCBzcGxpdCBiZWluZyBob3ZlcmVkIGlmIGFueS5cbiAgICovXG4gIGNlbGxEcmFnT3ZlcihlLCBjZWxsLCBjZWxsRGF0ZSwgc3BsaXQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgaWYgKHNwbGl0IHx8IHNwbGl0ID09PSAwKSBjZWxsLmhpZ2hsaWdodGVkU3BsaXQgPSBzcGxpdDtcbiAgfVxuICAvKipcbiAgICogV2hlbiBldmVudCBkcmFnIGxlYXZlcyBhIGNlbGwvc3BsaXQuXG4gICAqIFJlbW92ZSB0aGUgY2VsbC9zcGxpdCBoaWdobGlnaHRlZCBzdGF0ZS5cbiAgICogV2FybmluZzogY2VsbCBkcmFnbGVhdmUgZXZlbnQgaGFwcGVucyBBRlRFUiBhbm90aGVyIGNlbGwgZHJhZ2VudGVyIVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgYXNzb2NpYXRlZCBET00gZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsIFRoZSBjZWxsIGNvbXBvbmVudCdzICRkYXRhLlxuICAgKi9cbiAgY2VsbERyYWdMZWF2ZShlLCBjZWxsKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkgcmV0dXJuO1xuICAgIGNlbGwuaGlnaGxpZ2h0ZWRTcGxpdCA9IGZhbHNlO1xuICAgIGlmIChkcmFnT3ZlckNlbGwuY2VsbCA9PT0gY2VsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGRyYWdPdmVyQ2VsbC50aW1lb3V0KTtcbiAgICAgIGRyYWdPdmVyQ2VsbCA9IHsgZWw6IG51bGwsIGNlbGw6IG51bGwsIHRpbWVvdXQ6IG51bGwgfTtcbiAgICAgIGNlbGwuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9uIHN1Y2Nlc3NmdWwgZXZlbnQgZHJvcCBpbnRvIGEgY2VsbC9zcGxpdC5cbiAgICogQ2hhbmdlIHRoZSBldmVudCBzdGFydCBhbmQgZW5kIHRpbWUgYW5kIHJlbW92ZSB0aGUgZXZlbnQgZHJhZ2dpbmcgc3RhdGVcbiAgICogYW5kIGNlbGwvc3BsaXQgaGlnaGxpZ2h0ZWQgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBhc3NvY2lhdGVkIERPTSBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNlbGwgVGhlIGNlbGwgY29tcG9uZW50J3MgJGRhdGEuXG4gICAqIEBwYXJhbSB7RGF0ZX0gY2VsbERhdGUgVGhlIGhvdmVyZWQgY2VsbCBzdGFydGluZyBkYXRlLlxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHNwbGl0IFRoZSBvcHRpb25hbCBzcGxpdCBiZWluZyBkcm9wcGVkIGludG8sIGlmIGFueS5cbiAgICovXG4gIGNlbGxEcmFnRHJvcChlLCBjZWxsLCBjZWxsRGF0ZSwgc3BsaXQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY2xlYXJUaW1lb3V0KGRyYWdPdmVyQ2VsbC50aW1lb3V0KTtcbiAgICBkcmFnT3ZlckNlbGwgPSB7IGVsOiBudWxsLCBjZWxsOiBudWxsLCB0aW1lb3V0OiBudWxsIH07XG4gICAgY29uc3QgdHJhbnNmZXJEYXRhID0gSlNPTi5wYXJzZShlLmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiZXZlbnRcIikgfHwgXCJ7fVwiKTtcbiAgICBsZXQgZXZlbnQsIGFkZFRvVmlldztcbiAgICBpZiAoZHJhZ2dpbmcuZnJvbVZ1ZUNhbCAhPT0gdGhpcy5fdnVlY2FsLl8udWlkKSB7XG4gICAgICBjb25zdCB7IF9laWQsIHN0YXJ0LCBlbmQsIGR1cmF0aW9uLCAuLi5jbGVhblRyYW5zZmVyRGF0YSB9ID0gdHJhbnNmZXJEYXRhO1xuICAgICAgZXZlbnQgPSB0aGlzLl92dWVjYWwudXRpbHMuZXZlbnQuY3JlYXRlQW5FdmVudChjZWxsRGF0ZSwgZHVyYXRpb24sIHsgLi4uY2xlYW5UcmFuc2ZlckRhdGEsIHNwbGl0IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudCA9IHRoaXMuX3Z1ZWNhbC52aWV3LmV2ZW50cy5maW5kKChldnQpID0+IGV2dC5fZWlkID09PSBkcmFnZ2luZy5fZWlkKTtcbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgZXZlbnQgPSB0aGlzLl92dWVjYWwubXV0YWJsZUV2ZW50cy5maW5kKChldnQpID0+IGV2dC5fZWlkID09PSBkcmFnZ2luZy5fZWlkKTtcbiAgICAgICAgYWRkVG9WaWV3ID0gISFldmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0cmFuc2ZlckRhdGEuZW5kVGltZU1pbnV0ZXMgLSB0cmFuc2ZlckRhdGEuc3RhcnRUaW1lTWludXRlcztcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kLCAuLi5jbGVhblRyYW5zZmVyRGF0YSB9ID0gdHJhbnNmZXJEYXRhO1xuICAgICAgICBldmVudCA9IHRoaXMuX3Z1ZWNhbC51dGlscy5ldmVudC5jcmVhdGVBbkV2ZW50KGNlbGxEYXRlLCBkdXJhdGlvbiwgeyAuLi5jbGVhblRyYW5zZmVyRGF0YSwgc3BsaXQgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhcnQ6IG9sZERhdGUsIHNwbGl0OiBvbGRTcGxpdCB9ID0gZXZlbnQ7XG4gICAgdGhpcy5fdXBkYXRlRXZlbnRTdGFydEVuZChlLCBldmVudCwgdHJhbnNmZXJEYXRhLCBjZWxsRGF0ZSk7XG4gICAgaWYgKGFkZFRvVmlldykgdGhpcy5fdnVlY2FsLmFkZEV2ZW50c1RvVmlldyhbZXZlbnRdKTtcbiAgICBldmVudC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgIGlmIChzcGxpdCB8fCBzcGxpdCA9PT0gMCkgZXZlbnQuc3BsaXQgPSBzcGxpdDtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgY2VsbC5oaWdobGlnaHRlZFNwbGl0ID0gbnVsbDtcbiAgICBjYW5jZWxWaWV3Q2hhbmdlID0gZmFsc2U7XG4gICAgZHJhZ2dpbmcudG9WdWVDYWwgPSB0aGlzLl92dWVjYWwuXy51aWQ7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgZXZlbnQ6IHRoaXMuX3Z1ZWNhbC5jbGVhbnVwRXZlbnQoZXZlbnQpLFxuICAgICAgb2xkRGF0ZSxcbiAgICAgIG5ld0RhdGU6IGV2ZW50LnN0YXJ0LFxuICAgICAgLi4uKHNwbGl0IHx8IHNwbGl0ID09PSAwKSAmJiB7IG9sZFNwbGl0LCBuZXdTcGxpdDogc3BsaXQgfSxcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IHRoaXMuX3Z1ZWNhbC5jbGVhbnVwRXZlbnQodHJhbnNmZXJEYXRhKSxcbiAgICAgIGV4dGVybmFsOiAhZHJhZ2dpbmcuZnJvbVZ1ZUNhbFxuICAgICAgLy8gSWYgZXh0ZXJuYWwgZXZlbnQsIG5vdCBjb21pbmcgZnJvbSBhbnkgVnVlIENhbC5cbiAgICB9O1xuICAgIHRoaXMuX3Z1ZWNhbC4kZW1pdChcImV2ZW50LWRyb3BcIiwgcGFyYW1zKTtcbiAgICB0aGlzLl92dWVjYWwuJGVtaXQoXCJldmVudC1jaGFuZ2VcIiwgeyBldmVudDogcGFyYW1zLmV2ZW50LCBvcmlnaW5hbEV2ZW50OiBwYXJhbXMub3JpZ2luYWxFdmVudCB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChkcmFnZ2luZy5fZWlkKSB0aGlzLmV2ZW50RHJhZ0VuZChldmVudCk7XG4gICAgfSwgMzAwKTtcbiAgfVxuICAvKipcbiAgICogT24gZHJhZyBlbnRlciBvbiBhIHZpZXcgYnV0dG9uIG9yIG9uIHRvZGF5LCBwcmV2ICYgbmV4dCBidXR0b25zLlxuICAgKiBTZXRzIGEgaGlnaGxpZ2h0ZWQgc3RhdGUgb24gdGhlIGhvdmVyZWQgYnV0dG9uLCBhbmQgZ28gdG8gcmVxdWVzdGVkIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBhc3NvY2lhdGVkIERPTSBldmVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgaGVhZGVyIGVsZW1lbnQgYmVpbmcgaG92ZXJlZC4gT25lIG9mOlxuICAgKiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMsIG5leHQsIHRvZGF5LCB5ZWFycywgeWVhciwgbW9udGgsIHdlZWssIGRheS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlckRhdGEgVGhlIGhlYWRlciBjb21wb25lbnQncyAkZGF0YS5cbiAgICovXG4gIHZpZXdTZWxlY3RvckRyYWdFbnRlcihlLCBpZCwgaGVhZGVyRGF0YSkge1xuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkgcmV0dXJuO1xuICAgIGhlYWRlckRhdGEuaGlnaGxpZ2h0ZWRDb250cm9sID0gaWQ7XG4gICAgY2xlYXJUaW1lb3V0KGNoYW5nZVZpZXdUaW1lb3V0KTtcbiAgICBjaGFuZ2VWaWV3VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKFtcInByZXZpb3VzXCIsIFwibmV4dFwiXS5pbmNsdWRlcyhpZCkpIHtcbiAgICAgICAgdGhpcy5fdnVlY2FsW2lkXSgpO1xuICAgICAgICBjbGVhckludGVydmFsKHByZXNzUHJldk9yTmV4dEludGVydmFsKTtcbiAgICAgICAgcHJlc3NQcmV2T3JOZXh0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLl92dWVjYWxbaWRdLCBob2xkT3ZlclRpbWVvdXQpO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gXCJ0b2RheVwiKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocHJlc3NQcmV2T3JOZXh0SW50ZXJ2YWwpO1xuICAgICAgICBsZXQgdmlld0lkO1xuICAgICAgICBpZiAodGhpcy5fdnVlY2FsLnZpZXcuaWQuaW5jbHVkZXMoXCJ5ZWFyXCIpKSB7XG4gICAgICAgICAgdmlld0lkID0gdGhpcy5fdnVlY2FsLmVuYWJsZWRWaWV3cy5maWx0ZXIoKHZpZXcpID0+ICF2aWV3LmluY2x1ZGVzKFwieWVhclwiKSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdnVlY2FsLnN3aXRjaFZpZXcodmlld0lkIHx8IHRoaXMuX3Z1ZWNhbC52aWV3LmlkLCBuZXcgRGF0ZSgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLnNldEhvdXJzKDAsIDAsIDAsIDApKSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgdGhpcy5fdnVlY2FsLnN3aXRjaFZpZXcoaWQsIG51bGwsIHRydWUpO1xuICAgICAgdmlld0NoYW5nZWQgPSB0cnVlO1xuICAgIH0sIGhvbGRPdmVyVGltZW91dCk7XG4gIH1cbiAgLyoqXG4gICAqIE9uIGRyYWcgbGVhdmUgb24gYSB2aWV3IGJ1dHRvbiBvciBvbiB0b2RheSwgcHJldiAmIG5leHQgYnV0dG9ucy5cbiAgICogUmVtb3ZlcyB0aGUgaGlnaGxpZ2h0ZWQgc3RhdGUgb24gdGhlIGhvdmVyZWQgYnV0dG9uLCBhbmQgY2FuY2VsIHRoZSB0aW1lciB0b1xuICAgKiBnbyB0byB0aGUgcmVxdWVzdGVkIHZpZXcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBhc3NvY2lhdGVkIERPTSBldmVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgaGVhZGVyIGVsZW1lbnQgYmVpbmcgaG92ZXJlZC4gT25lIG9mOlxuICAgKiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMsIG5leHQsIHRvZGF5LCB5ZWFycywgeWVhciwgbW9udGgsIHdlZWssIGRheS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlckRhdGEgVGhlIGhlYWRlciBjb21wb25lbnQncyAkZGF0YS5cbiAgICovXG4gIHZpZXdTZWxlY3RvckRyYWdMZWF2ZShlLCBpZCwgaGVhZGVyRGF0YSkge1xuICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSkgcmV0dXJuO1xuICAgIGlmIChoZWFkZXJEYXRhLmhpZ2hsaWdodGVkQ29udHJvbCA9PT0gaWQpIHtcbiAgICAgIGhlYWRlckRhdGEuaGlnaGxpZ2h0ZWRDb250cm9sID0gbnVsbDtcbiAgICAgIGlmIChjaGFuZ2VWaWV3VGltZW91dCkgY2hhbmdlVmlld1RpbWVvdXQgPSBjbGVhclRpbWVvdXQoY2hhbmdlVmlld1RpbWVvdXQpO1xuICAgICAgaWYgKHByZXNzUHJldk9yTmV4dEludGVydmFsKSBwcmVzc1ByZXZPck5leHRJbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwocHJlc3NQcmV2T3JOZXh0SW50ZXJ2YWwpO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydCB7XG4gIERyYWdBbmREcm9wXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-cal/dist/drag-and-drop.es.js\n");

/***/ })

}]);